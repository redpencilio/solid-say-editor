<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/model/store-communicator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/model/store-communicator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Service, { inject as service } from '@ember/service';
import { tracked } from '@glimmer/tracking';
import rdflib from 'ember-rdflib';
import ForkableStore, { addGraphFor, delGraphFor } from 'solid-addon/utils/forking-store';
const RDFS = rdflib.Namespace("http://www.w3.org/2000/01/rdf-schema#")
import { SOLID } from 'solid-addon/utils/namespaces';
import { v4 as uuidv4 } from 'uuid';
const { Fetcher } = rdflib;
import { fetch as solidAuthClient } from 'solid-auth-client'

/**
 * Represents a communication service for the components to query 
 * the underlying forking store, which makes use of rdflib to access 
 * different datapods. 
 * @class ModelStoreCommunicatorService
 * @public
 * 
 * @property {Ember.Service} profile Ember profile service
 * @property {ForkableStore} store Forkable Store used to communicate with Solid
 * @property {NamedNode} privateTypeIndex NamedNode representing the private type index
 * @property {NamedNode} publicTypeIndex NamedNode representing the public type index
 * @property {List} insertCache Contains the locally changed quads
 * @property {Object} uuid_obj_map Maps a unique uuid to its corresponding object
 */
export default class ModelStoreCommunicatorService extends Service {
    @service profile;
    store = null;
    privateTypeIndex = null;
    publicTypeIndex = null;

    @tracked
    insertCache = [];

    uuid_obj_map = {};

    constructor() {
        super(...arguments);
        this.store = new ForkableStore();
        Fetcher.crossSiteProxyTemplate="https://proxy.linkeddatafragments.org/{uri}"
        this.fetcher = new Fetcher(this.store.graph, {solidAuthClient});
    }

    /** 
     * Find the type of the `subject` in RDF domain.  
     *
     * @param {NamedNode} subject is a RDFnode from rdflib.
     * @param {Context[]} triples is a list containing say-editor's context statements {subject, predicate, object}.
     * @returns {NamedNode} a NamedNode representing the type of the given `subject`.
     * 
     * @memberof ModelStoreCommunicatorService
     */
    getType(subject, triples) {
        const typequad = triples.find(triple => {
            return triple.subject === subject.value &amp;&amp; triple.predicate === "a";
        });
        if (typequad) {
            return rdflib.sym(typequad.object);
        }
    }


    /**
     * The graph of the given `type` will be searched inside 
     * the given `typeIndex` document. 
     * 
     * @param {NamedNode} type is a NamedNode representing the type as a uri. 
     * @param {NamedNode} typeIndex is a type index graph in which the graph of the given `type` will be searched.
     * @returns {NamedNode} representing the graph of the given `type` derived from the given `typeIndex` document or `undefined` if it can't be found.
     * 
     * @memberof ModelStoreCommunicatorService
     */
    getGraphByType_TypeIndex(type, typeIndex) {
        // Search for type registration in typeIndex
        if (type &amp;&amp; typeIndex) {
            const subject = this.store.any(undefined, SOLID("forClass"), type, typeIndex);
            if (subject) {
                return this.store.any(subject, SOLID("instance"), undefined, typeIndex);
            }
        }
        return undefined;
    }



    /**
     * Returns a `NamedNode` representing the graph of the given `type` 
     * The graph will be searched in the `publicTypeIndex` and `privateTypeIndex`.
     * 
     * @param {NamedNode} type is a NamedNode representing the type as a uri. 
     * @returns {NamedNode} representing the graph of the given `type`.
     * @throws {Error} thrown if no graph linked to the gievn `type` is found. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    getGraphByType(type) {
        const graph = this.getGraphByType_TypeIndex(type, this.publicTypeIndex) || this.getGraphByType_TypeIndex(type, this.privateTypeIndex);

        if (graph) {
            return graph;
        } else {
            throw new Error("No graph linked to this type found");
        }
    }



    /**
     * `NamedNode` representing the graph is derived form the given `subject` of the 
     * given `type`. It will first search in the `publicTypeIndex` and the `privateTypeIndex` 
     * documents first to derive the graph. 
     * It fallback to calling the `subject.doc()` if it couldn't find the graph in the type indices documents. 
     * 
     * @param {NamedNode} subject is a NamedNode representing the subject fo the `type`.
     * @param {NamedNode} type is a NamedNode reprensenting the type of the `subject`.
     * @returns {NamedNode} representing the graph of the given `subject` of `type`. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    getGraph(subject, type) {
        return this.getGraphByType_TypeIndex(type, this.publicTypeIndex) || this.getGraphByType_TypeIndex(type, this.privateTypeIndex) || subject.doc();
    }


    /**
     * Adds the given quad statement to the insert cache. 
     * 
     * @param {Statement} quad statement to add to the cache.
     * 
     * @memberof ModelStoreCommunicatorService
     */
    addQuadToCache({triple, objectUuid}) {
        this.insertCache = this.insertCache.filter(ins =>
            !(ins.triple.subject.equals(triple.subject) &amp;&amp;
                ins.triple.predicate.equals(triple.predicate) &amp;&amp;
                ins.triple.graph.equals(triple.graph) &amp;&amp;
                ins.objectUuid === objectUuid)
        );

        this.insertCache.push({triple, objectUuid});
    }

     /**
     * Fetches the quad statements from the forking store containing the given `subject` which has 
     * the given `attributes` or predicates.
     * 
     * @param {NamedNode} subject NamedNode representing the subject to be queried in the forking store.
     * @param {Object} attributes Object containing the predicate uri strings as key and predicate NamedNode as value. 
     * @param {NamedNode} graph NamedNode representing the graph in which the subject will be queried. 
     * @async
     * @returns {Promise&lt;Statement[]>} a promise resolved with the resulting quad statements from the forking store. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    fetchTriples(subject, attributes, graph) {
        return new Promise((resolve, reject) => {

            if (!graph) {
                graph = this.getGraph(subject);
            }

            this.fetcher.nowOrWhenFetched(graph, (ok, body, xhr) => {
                if (ok) {
                    let result_quads = []

                    if (attributes) {
                        for (let attrib of Object.keys(attributes)) {
                            result_quads = result_quads.concat(this.store.match(subject, attributes[attrib], undefined, graph));
                        }
                    } else {
                        result_quads = this.store.match(subject, undefined, undefined, graph);
                    }

                    resolve(result_quads);
                } else {
                    reject(new Error("Could not load quads"))
                }
            });
        })

    }

    fetchRemoteQuads(subject, attributes, graph) {
        return new Promise((resolve, reject) => {
            this.fetchTriples(subject, attributes, graph).then(quads => {
                resolve(quads);
            }).catch(err => {
                resolve([]);
            })
        });
    }

     /**
     * Retrieves metadata of the resource. (ex. rdfs:label, rdfs:comment, dct:description etc....)
     * @param {NamedNode} resource NamedNode for which the metadata will be retrieved from its graph. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    async fetchResourceMetaData(resource) {


        let metaDatas = [RDFS("label"), RDFS("comment")];
        let attribObj = metaDatas.reduce((map, node) => {
            map[node.value] = node;
            return map
        }, {});


        let quads = await this.fetchRemoteQuads(resource, attribObj);

        return quads.reduce((map, quad) => {
            map[quad.predicate.value] = quad.object;
            return map;
        }, {});
    }


      /**
     * Fetches all the subjects in the given `graph`
     * @param {NamedNode} graph NamedNode representing the graph 
     * @returns {NamedNode[]} list of NamedNode containing the different subjects from the given `graph`
     * 
     * @memberof ModelStoreCommunicatorService
     */
    fetchSubjectsByGraph(graph) {
        return new Promise((resolve, reject) => {
            this.store.fetcher.nowOrWhenFetched(graph, (ok, body, xhr) => {
                if (ok) {
                    let quads = this.store.match(undefined, undefined, undefined, graph);
                    let subjects = new Set(quads.map(quad => quad.subject));
                    resolve(subjects);
                } else {
                    reject(new Error("Could not load subjects"))
                }
            })
        });
    }


    /**
     * Fetches the type indices from the given webID and store them locally in the forking store. 
     * @param {String} webId string representation of the user's solid webID. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    async fetchTypeIndexes(webId) {
        const me = rdflib.sym(webId);
        await this.store.load(me.doc());
        this.privateTypeIndex = this.store.any(me, SOLID("privateTypeIndex"), undefined, me.doc());
        this.publicTypeIndex = this.store.any(me, SOLID("publicTypeIndex"), undefined, me.doc());
        await this.store.load(this.privateTypeIndex);
        await this.store.load(this.publicTypeIndex);
    }

    

    /**
     * Fetches types defined in both public and private type indices. 
     * 
     * @returns {NamedNode} NamedNode representing the types 
     *                    defined in the public and private type indices. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    fetchTypes() {
        let publicTypeRegs = this.store.match(undefined, SOLID("forClass"), undefined, this.publicTypeIndex);
        let privateTypeRegs = this.store.match(undefined, SOLID("forClass"), undefined, this.privateTypeIndex);
        let typeRegs = publicTypeRegs.concat(privateTypeRegs);
        let types = typeRegs.map(typeReg => typeReg.object);
        return types;
    }



    /**
     * Resets the graph from the local store by reloading the data from the 
     * web store. Helper method using the store's fetcher directly.
     * 
     * @param {NamedNode} graph a graph for which the forking store needs to reset. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    fetcherReset(graph) {
        this.store.fetcher.unload(addGraphFor(graph));
        this.store.fetcher.unload(delGraphFor(graph));
    }



    /**
     * Reset the local store by going through graphs in the insert cache. The insert cache contains emphemeral 
     * statements which still hasn't been persisted yet.  
     * 
     * @returns {Statement[]} a list of quads in the insert cache before the reset. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    reset() {
        let graphs = this.insertCache.map(({triple, objectUuid}) => this.getGraph(triple.subject));
        let cache = this.insertCache;
        for (let graph of graphs) {
            this.fetcherReset(graph);
        }
        return cache;
    }


    /**
     * Persists the changes from the local store to the web store. 
     * 
     * @memberof ModelStoreCommunicatorService
     */
    persist() {
        this.insertCache.forEach(({triple, objectUuid}) => {
            this.uuid_obj_map[objectUuid] = triple.object.value.trim();
        })
        this.insertCache = [];
        this.store.persist();
    }

    /**
     * Updates a quad in the local rdflib-store
     * 
     * @memberof ModelStoreCommunicatorService
     * 
     * @param {Statement} oldQuad The quad to be updated
     * @param {Statement} newQuad The new version of the quad
     * @param {string} objectUuid Id that uniquely identifies the object of the quads
     */
    updateQuad(oldQuad, newQuad, objectUuid){
        const dels = this.store.match(oldQuad.subject, oldQuad.predicate, oldQuad.object, oldQuad.graph);
        const ins = [newQuad];
        if (dels.length &amp;&amp; dels[0].object.value.trim() !== newQuad.object.value.trim()) {
            this.profile.madeChanges = true;
            this.addQuadToCache({ triple: ins[0], objectUuid });
            this.store.addAll(ins);
            this.store.removeStatements(dels);
        }
    }

    addObjectToUuidMap(object){
        let uuidVal = uuidv4();
        this.uuid_obj_map[uuidVal] = object.value;
        return uuidVal;
    }

}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="EditInEditorBlockHandler.html">EditInEditorBlockHandler</a></li><li><a href="File.html">File</a></li><li><a href="FileCreateModalComponent.html">FileCreateModalComponent</a></li><li><a href="FileListComponent.html">FileListComponent</a></li><li><a href="FileSelectorComponent.html">FileSelectorComponent</a></li><li><a href="Folder.html">Folder</a></li><li><a href="Form.html">Form</a></li><li><a href="LoginButtonComponent.html">LoginButtonComponent</a></li><li><a href="ModalComponent.html">ModalComponent</a></li><li><a href="ModalsVocabDropdownComponent.html">ModalsVocabDropdownComponent</a></li><li><a href="ModelSerializer.html">ModelSerializer</a></li><li><a href="ModelStoreCommunicatorService.html">ModelStoreCommunicatorService</a></li><li><a href="module.exports.html">exports</a></li><li><a href="PredicateSelectorComponent.html">PredicateSelectorComponent</a></li><li><a href="ProfileHeaderComponent.html">ProfileHeaderComponent</a></li><li><a href="ProfileService.html">ProfileService</a></li><li><a href="SaveResetBlockHandler.html">SaveResetBlockHandler</a></li><li><a href="SaySolidFetchCard.html">SaySolidFetchCard</a></li><li><a href="SaySolidFilesCard.html">SaySolidFilesCard</a></li><li><a href="SaySolidLoginCard.html">SaySolidLoginCard</a></li><li><a href="SaySolidSaveResetCard.html">SaySolidSaveResetCard</a></li><li><a href="SaySolidTypesCard.html">SaySolidTypesCard</a></li><li><a href="SubjectCreateModalComponent.html">SubjectCreateModalComponent</a></li><li><a href="SubjectSelectorComponent.html">SubjectSelectorComponent</a></li><li><a href="TripleCreateModalComponent.html">TripleCreateModalComponent</a></li><li><a href="TripleFormComponent.html">TripleFormComponent</a></li><li><a href="TypeSelectorComponent.html">TypeSelectorComponent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#card">card</a></li><li><a href="global.html#execute">execute</a></li><li><a href="global.html#extractUuid">extractUuid</a></li><li><a href="global.html#fromRDFa">fromRDFa</a></li><li><a href="global.html#handle">handle</a></li><li><a href="global.html#handleClose">handleClose</a></li><li><a href="global.html#processNode">processNode</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#scope">scope</a></li><li><a href="global.html#type">type</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.5</a> on Wed Aug 12 2020 15:45:42 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
